# 변수의 영역

## 변수의 영역(Scope)

- 프로그램에서 변수가 가시적인 영역

### 영역의 종류

1. 지역변수 (Local Variable)
   - block 내부에 선언된 변수
   - 변수가 선언된 부프로그램이나 block 내부에서 가시적, 외부에서는 비가시적
2. 비지역변수 (Nonlocal Variable)
   - 부프로그램이나 block 내부에서 가시적, 내부에 선언되어있지 않음
3. 전역변수 (Global variable)
   - 프로그램 전체 영역에서 가시적인 변수

### 영역 규칙 (Scope Rule)

- 프로그램의 어떤 지점에서 사용된 변수 이름을 어느 선언문에서 선언된 변수와 대응시켜줄 것인지를 결정하는 규칙

1. 정적영역 규칙 (Static scope rule)
2. 동적영역 규칙 (Dynamic scope rule)

### 중첩된 구조 (Nested structure)

- 부프로그램이 내부에 중첩된(Nested) 부프로그램을 정의할 수 있는 언어
  ex) Ada
- 중첩된 부프로그램을 정의할 수 없는 언어
  ex) C (단,Block으로 중첩될 수 있다)

부프로그램들의 공간적 배치 구조 (Program textual layout)에 근거하고 있음 => Spatial (공간적)

- 정적 부모 (Static Parent) : 자신을 직접 둘러싸고 있는 부프로그램.
- 정적 조상 (Static Ancestors) : 자신을 둘러싸고 있는 모든 부프로그램들

사용자 변수에 대한 선언문을 찾는 순서

1. 변수이름이 사용된 부프로그램 내에서 찾는다. => 찾으면 지역변수
2. 변수이름이 사용된 부프로그램의 정적 부모 내에서 찾는다. => 비지역 변수
3. 선언문을 찾을 때까지 2번 과정을 반복하여 모든 정적 조상 내에서 순서대로 찾는다. => 마지막일 경우 전역 변수
4. 끝까지 못찾으면 오류를 출력함

### 은폐되는 변수 (Hidden Variable)

변수의 이름이 사용된 지점에서 가까운 곳에 선언문이 있으면 그곳의 정적 조상에 선언된 동일한 변수는 변수 사용지점에서는 보이지 않음.

```C++
int main(){
    int a = 10;
    {
        int a = 2;
        std::cout<<a; // 출력: 2
    }
   
}
```

프로그램의 tree구조

```
main
{
    A
    {
        C{}
        D{}
        call C;
        call D;
    }
    B
    {
    	E{}
    	call A;
    	call E;
    }
    call A;
    call B;
}
```

main의 자손은 A, B

A의 자손은 C, D

바람직한 호출 Graph

![바람직한 호출 그라프](https://github.com/noelvalent/TIL/blob/master/concept_of_programming_language/imgs/20190728.PNG)

![가능한 호춯 그라프](https://github.com/noelvalent/TIL/blob/master/concept_of_programming_language/imgs/20190728-1.PNG)

### 정적 영역규칙에 대한 평가

장점

- 신뢰성 향상 : 비지역 변수에 대한 접근 방법이 결정적(deterministic)이고, 효과적이다.
- 가독성 향상 : 비지역 변수의 속성을 정적으로 알 수 있다.

단점

- 전역 변수는 모든 부프로그램에 가시적
- 바람직하지 않은 호출이가능 => 유지관리 비용 증가
- 요구 사항이 변경됬을때 재 설계에 어려움이 큼

### 동적 영역 규칙

단위 프로그램들의 호출순서(Calling sequence)에 근거하고 있다.

즉 시간적(Temporal)이다. => 동적영역은 실행 시간에 의해 결정된다.

사용된 변수를 찾는 순서

1. 변수 이름이 사용된 부프로그램 내에서 탐색 => 지역변수
2. 변수 이름이 사용된 부프로그램을 호출한 부프로그램 내에서 탐색
3. 선언문을 찾을 때까지 2번 과정을 반복하여 호춯된 부프로그램을 역순으로 탐색
4. 끝까지 못찾으면 에러

장점

- 부프로그램을 호출할 때, 매개변수를 인자로 전달할 필요가 없다.

단점

- 신뢰성 저하
- 비지역 변수에 대한 동적 타입검사 때문에 실행 시간 증가
- 가독성 저하
- 비지역변수에 대한 접근시간이 더 많이듬.

### 정적영역 규칙 vs 동적영역 규칙

- SSR이 DSR에 비해 가독성, 신뢰성, 실행 비용 면에서 우수하다.

- SSR을 적용하는 언어가 DDR에 비해 많다.

- DSR을 적용하는 언어는 SSR도 지원한다. (perl, common lisp)
- DSR을 적용하던 언어에서 SSR을 적용하는 언어로 발전하는 경우도 있다. Scheme : Lisp의 방언
- 요즘 개발되는 대부분의 언어는 SSR을 적용함.

### 영역(Scope)과 존속기간(Lifetime)

영역 : 변수 선언문부터 부프로그램의 끝 부분까지

존속기간 : 부프로그램이 호출되어 실행을 시작한 시점부터 부프로그램의 실행이 종료되어 return 할 때까지

### 참조환경 (Referencing Enviroment)

문장에 가시적인 모든 이름들의 집합

SSR이 적용되는 경우

- 지역변수
- 정적 조상의 지역변수
- 은폐되는 변수는 제외

DSR이 적용되는 경우

- 지역변수
- 문장이 실행될 때까지 실행된 부프로그램들(Active Subprogram)의 지역변수=> Active Subprogram: 호출이 되어 실행되었으나 종료되지 않은 부프로그램
- 은폐되는 변수는 제외
