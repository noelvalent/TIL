# 배열

## 배열
- 동일한 데이터 타입을 가지는 값들의 모임
- 각 원소는 첨자에 의해 인식됨 (이때 첨자는 첫 번째 원소를 기준으로 한 상대적인 위치를 의미)

배열에 관한 논점
- 첨자에 허용된 타입
- 첨자의 범위 검사를 할 것인지? 범위는 언제 정해지는지 C: 컴파일, 파이썬: 실행시
- 배열에 메모리를 언제 할당할 것인지
- 배열 개체의 초기화를 허용할 것인지
- 쪼개는 것을 허용할 것인지

### 인덱스 (Index)

- 인덱싱 (indexing): 배열이름과 첨자를 가지고 특정 원소에 대응시키는 것
	- Fortran, PL/I, Ada는 () 나머지는 []사용
- 첨자의 데이터 타입
	- 정수 (Fortran, c, java)
	- integer, boolean, char, enum (Pascal, Ada)
- 첨자 개수 (다차원 배열)
	- 3개로 한정(fortran 1), 7개로 한정(fortran77)
	- 그러나 그 외의 언어에서는 제한 없음

### 배열의 종류
1. 정적 배열 (fortran77)
- 첨자의 최대 범위가 정적으로 수행 전에 결정됨
- 배열의 메모리 할당도 정적으로
- 장점 : 실행 효율성

2. 고정 스택 동적 배열 (C의 local 배열: int arr[10])
- 첨자의 최대 범위는 정적으로 결정되나
- 배열의 메모리 할당은 실행중에 스텍에 이루어진다.
- 장점: 공간 효율성

3. 스택 동적 배열 (Ada의 declare block) 
- 첨자 범위, 메모리 공간은 수행 중 동적으로 결정됨 (스텍에)
- 그러나 시작할 때 한 번 결정되면 그 변수 생명주기가 끝날 때까지 변할 수 없음
- 장점: 융통성 (배열이 사용되기 직전에야 첨자 범위, 배열 크기 등을 알 수 있을때 유용)
```ada
GET (LIST_LEN);
Declare // 배열 할당
LIST: array (1 .. LIST_LEN) of INTEGER;
```

4. 고정 힙 동적 배열
- 스택 동적 배열과 동일하나 메모리 위치가 스텍이 아닌 힙임
- C의 malloc/free, C++의 new/delete로 조작되는 배열
- Java의 모든 배열, C#도 이 유형의 배열 제공

5.  힙 동적 배열
- 첨자 범위, 메모리 공간이 수행 중 동적으로 결정되며 수행하다가 변할 수 있음
- Java, C# 의 ArrayList
- Perl, js, php의 패턴 매칭 ex) @list = (1,2,4,7,10); push(@list, 13, 17);;

### 배열의 초기화
주로 메모리에 자리잡은 순서대로 초기화됨

-PASCAL은 별도 지원이 없음
- C: int stuff [] = {2, 4, 6, 7};
- Ada: Bunch: array (1..5) of INTEGER := (1=>3, 3=>4, others => 0);
- Fortran: INTEGER LIST(3) DATA LIST /0, 5, 5/

### 배열 연산
-Ada: 배열 지정 (:=), 이어붙이기, 같은지 비교
- FORTRAN: 행렬, 백터 연산 라이브러리가 풍부함
- APL: 가장 강력함: 배열에 대한 4칙 연산, 백터의 원소 역순, 행렬의 행/열의 역순, 전치행렬, 역행렬 
Ex) A + B, A x B, A +.x B (내적)

### 정방형/비정방형 배열

정방형 배열(rectangle array)
모든 행이 동일 개수의 원소들을 포함, 모든 열이 동일 개수의 원소들을 포함
myArr[3, 7] // in Fortran, Ada, C#

비정방형 배열(jagged array) 행, 열의 크기가 동일하지 않는 다차원 배열
- 행렬이 3개 행을 포함하고, 첫번째 행은 5개 원소, 두번째 행은 7개 원소, 세번째행은 12원소를 포함할 때
- 다차원 배열이 실제로 배열들로 구성된 배열로 보일 때 가능
- myArray[3][7]// C, C++, Java, 사실 C#도 가능

### 배열의 슬라이스(slice)
배열의 부분을 한 단위 (또 다른 작은 배열)로 보는 것
Fortran95: 파이썬과 비슷
```FORTRAN95
Integer vector(1:10), Mat(1:3, 1:3),
Cube(1:3, 1:3, 1:4)

Vector(3:6)
Mat(1:3, 2)
Mat(3, 1:3)
Cube(1:3, 1:3, 2)
Vector(2:10:2)
```
Ada: 1차원 슬라이스 연산만 지원
List(4 .. 10)

### 배열의 구현
배열 원소의 접근에 대한 코드를 컴파일러가 생성
- 접근 함수를 통해서 첨자 식을 배열의 한 주소에 사상
- 주소(list[k]) = 주소(list[1]) + (k-1) * 원소크기 = (주소(list[1])-원소크기) + (k * 원소크기))// 상수부분 + 변수부분

서술자(Descriptor)
- 접근 함수 구성, 인덱스 범위 검사 (첨자범위가 동적)에 필요한 정보 포함
- 컴파일시간/실행시간 서술자

![일차원배열서술자](https://github.com/noelvalent/TIL/blob/master/concept_of_programming_language/imgs/190731.png)
![다차원배열서술자](https://github.com/noelvalent/TIL/blob/master/concept_of_programming_language/imgs/190731-1.png)

다차원 배열의 저장
열 우선 순서(column major order): Fortran
행 우선 순서(row major order): 다른 언어 기본 데이터 타입

다차원 배열주소
a[I,j] = 주소(a[1,1]) + (i번째 행보다 위에 위치한 행의 개수 * 행의 크기 + j번째 열보다 왼쪽에 위치한 원소의 개수) * 원소_크기
=주소(a[1,1]) + ((i-1)*n+(j-1)) * 원소크기
=주소(a[1,1)-(n+1)*원소크기 + (i*n+j)*원소크기 // 상수부분 + 변수부분
